<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7 Pillars of Self</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        canvas {
            border: 2px solid #333;
            background: #549aa3;
            cursor: pointer;
            max-width: 100vw;
            max-height: 100vh;
            display: block;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .loading {
            position: absolute;
            color: white;
            font-size: 24px;
            z-index: 10;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            canvas {
                border: 1px solid #333;
                touch-action: pinch-zoom;
            }
            
            .loading {
                font-size: 18px;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }
        }
        
        @media (max-height: 600px) {
            canvas {
                height: 100vh !important;
                width: auto !important;
            }
        }
        
        canvas {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading...</div>
    <canvas id="gameCanvas" width="1920" height="1080"></canvas>

    <script>
        // Image Manager Class
        class ImageManager {
            constructor() {
                this.images = new Map();
                this.loadingPromises = [];
            }
            
            loadImage(name, src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.images.set(name, img);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${src}. Using fallback.`);
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = this.getFallbackColor(name);
                        ctx.fillRect(0, 0, 64, 64);
                        this.images.set(name, canvas);
                        resolve(canvas);
                    };
                    img.src = src;
                });
            }

            getFallbackColor(imageName) {
                const colors = {
                    'heart': '#FF0000',
                    'trophy': '#FFD700',
                    'money': '#00AA00',
                    'plant': '#228B22',
                    'brain': '#FF8C00',
                    'ring': '#FFD700',
                    'flame': '#FF4500'
                };
                return colors[imageName] || '#888888';
            }

            getImage(name) {
                return this.images.get(name);
            }

            async loadAllImages() {
                const imagePaths = {
                    'heart': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/assets/textures/heart.png',
                    'trophy': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/assets/textures/purpose.png',
                    'money': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/assets/textures/financial.png',
                    'plant': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/Assets-Nicolas/earth.png',
                    'brain': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/assets/textures/mental.png',
                    'ring': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/Assets-Nicolas/arm.png',
                    'flame': 'https://raw.githubusercontent.com/GuilhermeTrent/assets/refs/heads/main/Assets-Nicolas/spiritual.png'
                };

                for (const [name, path] of Object.entries(imagePaths)) {
                    this.loadingPromises.push(this.loadImage(name, path));
                }

                try {
                    await Promise.all(this.loadingPromises);
                    console.log('All images loaded successfully');
                } catch (error) {
                    console.error('Error loading images:', error);
                }
            }
        }

        // Entity Management System
        class Entity {
            constructor(id, tag) {
                this.id = id;
                this.tag = tag;
                this.active = true;
                this.components = new Map();
            }

            isActive() {
                return this.active;
            }

            destroy() {
                this.active = false;
            }

            getTag() {
                return this.tag;
            }
        }

        class EntityManager {
            constructor() {
                this.entities = [];
                this.entityMap = new Map();
                this.totalEntities = 0;
                this.entitiesToAdd = [];
            }

            addEntity(tag) {
                const entity = new Entity(this.totalEntities++, tag);
                this.entitiesToAdd.push(entity);
                return entity;
            }

            getEntities(tag = null) {
                if (tag === null) {
                    return this.entities;
                }
                return this.entityMap.get(tag) || [];
            }

            update() {
                this.removeDeadEntities(this.entities);
                for (let [tag, entityVec] of this.entityMap) {
                    this.removeDeadEntities(entityVec);
                }

                for (let entity of this.entitiesToAdd) {
                    this.entities.push(entity);
                    if (!this.entityMap.has(entity.getTag())) {
                        this.entityMap.set(entity.getTag(), []);
                    }
                    this.entityMap.get(entity.getTag()).push(entity);
                }
                this.entitiesToAdd = [];
            }

            removeDeadEntities(entityVec) {
                for (let i = entityVec.length - 1; i >= 0; i--) {
                    if (!entityVec[i].isActive()) {
                        entityVec.splice(i, 1);
                    }
                }
            }
        }

        // Command System
        class Command {
            constructor(name, type) {
                this.name = name;
                this.type = type;
            }

            getName() { return this.name; }
            getType() { return this.type; }
        }

        // Base Scene Class
        class Scene {
            constructor(gameEngine) {
                this.game = gameEngine;
                this.entityManager = new EntityManager();
                this.commands = new Map();
                this.isPaused = false;
                this.hasEnded = false;
                this.currentFrame = 0;
            }

            update(dt) {}
            render(ctx) {}
            handleAction(command) {}
            registerAction(key, action) {
                this.commands.set(key, action);
            }
            getActionMap() {
                return this.commands;
            }
            onEnd() {}
        }

        // Menu Scene
        class Scene_Menu extends Scene {
            constructor(gameEngine) {
                super(gameEngine);
                this.registerActions();
            }

            registerActions() {
                this.registerAction('Enter', 'PLAY');
                this.registerAction('Escape', 'QUIT');
            }

            update(dt) {
                this.entityManager.update();
            }

            render(ctx) {
                const canvas = ctx.canvas;
                const isMobile = window.innerWidth <= 768;

                ctx.fillStyle = '#549aa3';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const titleSize = isMobile ? 80 : 100;
                const subtitleSize = isMobile ? 45 : 60;
                const buttonSize = isMobile ? 40 : 50;
                const footerSize = isMobile ? 35 : 40;

                ctx.fillStyle = 'black';
                ctx.font = `bold ${titleSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('7   Pillars   of   Self', canvas.width / 2, isMobile ? 150 : 250);

                ctx.font = `${subtitleSize}px Arial`;
                const subtitleY = isMobile ? 220 : 400;
                if (isMobile) {
                    ctx.fillText('A Journey of Self-Discovery', canvas.width / 2, subtitleY);
                    ctx.fillText('and Growth', canvas.width / 2, subtitleY + 50);
                } else {
                    ctx.fillText('A Journey of Self-Discovery and Growth', canvas.width / 2, subtitleY);
                }

                ctx.font = `${buttonSize}px Arial`;
                const buttonY = isMobile ? 350 : 700;
                if (isMobile) {
                    ctx.fillText('Tap to Begin', canvas.width / 2, buttonY);
                } else {
                    ctx.fillText('Press Enter to Begin or Click Here', canvas.width / 2, buttonY);
                }

                ctx.font = `${footerSize}px Arial`;
                ctx.fillText('Emotional Fitness Academy', canvas.width / 2, isMobile ? 500 : 1000);
            }

            handleAction(command) {
                if (command.getType() === 'START') {
                    if (command.getName() === 'PLAY') {
                        this.game.changeScene('PLAY', new Scene_Game(this.game));
                    } else if (command.getName() === 'QUIT') {
                        this.onEnd();
                    }
                }
            }

            handleClick(x, y) {
                this.game.changeScene('PLAY', new Scene_Game(this.game));
            }

            onEnd() {
                console.log('Game ended');
            }
        }
        // Reflection Scene
        class Scene_Reflection extends Scene {
            constructor(gameEngine, message, nextScene) {
                super(gameEngine);
                this.message = message;
                this.nextScene = nextScene;
                this.registerActions();
            }

            registerActions() {
                this.registerAction('Enter', 'CONTINUE');
                this.registerAction('Escape', 'MENU');
            }

            update(dt) {
                this.entityManager.update();
            }

            render(ctx) {
                const canvas = ctx.canvas;
                const isMobile = window.innerWidth <= 768;

                // Soft background color for reflection
                ctx.fillStyle = '#f0f8ff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const titleSize = isMobile ? 50 : 60;
                const messageSize = isMobile ? 32 : 40;
                const instructionSize = isMobile ? 28 : 35;

                ctx.fillStyle = '#2c3e50';
                ctx.font = `bold ${titleSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('Reflection', canvas.width / 2, isMobile ? 100 : 150);

                // Draw the reflection message
                ctx.font = `${messageSize}px Arial`;
                ctx.fillStyle = '#34495e';

                // Break the message into multiple lines for better readability
                const words = this.message.split(' ');
                const maxWordsPerLine = isMobile ? 6 : 10;
                const lines = [];

                for (let i = 0; i < words.length; i += maxWordsPerLine) {
                    lines.push(words.slice(i, i + maxWordsPerLine).join(' '));
                }

                const startY = isMobile ? 200 : 300;
                const lineHeight = isMobile ? 45 : 55;

                lines.forEach((line, index) => {
                    ctx.fillText(line, canvas.width / 2, startY + index * lineHeight);
                });

                // Draw the centered image related to the pillar
                const imageType = this.game.lastImageType || 'heart';
                const image = this.game.imageManager.getImage(imageType);
                if (image) {
                    const imageSize = isMobile ? 180 : 260;
                    ctx.drawImage(image, canvas.width / 2 - imageSize / 2, startY + lines.length * lineHeight + 30, imageSize, imageSize);
                }

                // Draw the external link text
                ctx.font = `${instructionSize}px Arial`;
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('To know more details please visit:', canvas.width / 2, canvas.height - 180);
                ctx.fillStyle = '#0000EE';
                ctx.fillText('https://efitacademy.ca/fundamentally-me-7-pillars-of-self/', canvas.width / 2, canvas.height - 140);

                // Instructions
                ctx.font = `${instructionSize}px Arial`;
                ctx.fillStyle = '#7f8c8d';
                const instructionY = canvas.height - (isMobile ? 100 : 80);
                if (isMobile) {
                    ctx.fillText('Tap anywhere to continue', canvas.width / 2, instructionY);
                } else {
                    ctx.fillText('Click anywhere or press Enter to continue', canvas.width / 2, instructionY);
                }
            }

            handleClick(x, y) {
                this.continue();
            }

            handleAction(command) {
                if (command.getType() === 'START') {
                    if (command.getName() === 'CONTINUE') {
                        this.continue();
                    } else if (command.getName() === 'MENU') {
                        this.game.changeScene('MENU', new Scene_Menu(this.game));
                    }
                }
            }

            continue() {
                this.game.changeScene('PLAY', this.nextScene);
            }
        }
        // Game Scene
        class Scene_Game extends Scene {
            constructor(gameEngine) {
                super(gameEngine);
                this.currentPillar = 0;
                this.TOTAL_PILLARS = 7;
                this.journeyFinished = false;
                this.clickLocked = false;
                this.state = 'ShowOptions';
                this.hasStarted = false; 
                
                this.pillarTitles = [
                    "Emotional", "Purpose", "Financial", "Physical",
                    "Mental", "Environmental", "Spiritual"
                ];
                
                this.pillarQuestions = [
                    "Which of these words most reflects the state of your heart right now?",
                    "Which of these words most reflects where you're being called to step forward in your life?",
                    "Which of these words best describes the relationship you want with your finances today?",
                    "Which of these words most speaks to your body's wisdom in this moment?",
                    "Which of these words most resonates with the mindset you'd like to strengthen today?",
                    "Which of these words most captures how you want to engage with your environment today?",
                    "Which of these words most speaks to your spirit's calling in this moment?"
                ];
                
                this.pillarColors = [
                    '#87CEEB',
                    '#D8BFD8',
                    '#ADD8E6',
                    '#98FB98',
                    '#90EE90',
                    '#FFE4B5',
                    '#FFA07A'
                ];
                
                this.pillarOptions = [
                    ["Awareness", "Vulnerability", "Compassion", "Connection"],
                    ["Vision", "Legacy", "Calling", "Contribution"],
                    ["Security", "Abundance", "Discipline", "Growth"],
                    ["Grounding", "Vitality", "Balance", "Resilience"],
                    ["Adaptability", "Control", "Resilience", "Optimism"],
                    ["Stewardship", "Sanctuary", "Regeneration", "Harmony"],
                    ["Transcendence", "Sacredness", "Alignment", "Ritual"]
                ];
                
                this.pillarReflections = [
                    [
                        "Pause for a moment—what emotion is rising within you right now, and what might it be trying to teach you?",
                        "What truth are you hiding from yourself that, if spoken aloud, could set you free?",
                        "How would your inner dialogue change today if you treated yourself with the same kindness you extend to others?",
                        "Where in your life do you long for deeper feeling or belonging—and what small step could you take today to build that bridge?"
                    ],
                    [
                        "Close your eyes—what future do you see for yourself—and what's one bold step toward bringing that vision to life?",
                        "When people tell your story years from now, what impact do you hope they remember—and how can you begin creating that today?",
                        "What activity pulls you into flow so completely you lose track of time—and how might you honor that calling more often?",
                        "Think of someone who needs what you have to give—what's the smallest way you could reach out and offer your gifts right now?"
                    ],
                    [
                        "How would your life shift if you felt truly protected against tomorrow's uncertainties—and what first step can you take to build that safety net?",
                        "Where in your finances do you already experience plenty—and how could you cultivate that sense of plenty to overflow into other areas of your life?",
                        "What habit around spending or saving feels hardest to maintain—and what gentle tweak could you introduce right now to strengthen your financial momentum?",
                        "Imagine your money as a seed—what would it take to nourish it so that it flourishes, supports you, and seeds new possibilities?"
                    ],
                    [
                        "When was the last time you felt fully rooted in your body—and what simple practice could you do right now to reconnect with that sense of stability?",
                        "What movement or ritual makes you feel most alive—and how might you carve out even five minutes today to honor that spark?",
                        "Which part of your daily rhythm feels out of sync—and what single change could bring you back into harmony?",
                        "Think back to a moment when your body carried you through difficulty—what inner strength did you discover, and how can you draw on it now?"
                    ],
                    [
                        "What new possibility could you create if you leaned into change instead of resisting it?",
                        "Where in your life do you feel most out of control—and what small action could bring you back to your center?",
                        "Recall a time you bounced back stronger than before—how can that strength guide you today?",
                        "If you believed the best was yet to come, what bold step would you take right now?"
                    ],
                    [
                        "What responsibility do you feel to care for the spaces you inhabit—inside your mind, in your home, and in the wider world—and what's one small act you could take today to honor that responsibility?",
                        "Where do you instinctively seek refuge when life feels overwhelming—and how might you cultivate that sense of safety and peace within yourself, no matter where you are?",
                        "What part of your inner or outer environment feels depleted or worn—and what simple ritual or change could you introduce now to begin its renewal?",
                        "In what ways could you bring more balance between your inner landscape and the natural world—what is one step toward creating that flow of give-and-take in your life?"
                    ],
                    [
                        "What would it feel like if you could rise above your daily worries and glimpse something greater—where would you look, and what would you hope to discover?",
                        "Where in your life do you already sense the divine or the profound, and how might you honor that spark more fully in your everyday moments?",
                        "Imagine your actions, values, and spirit flowing in perfect harmony—what's the one shift you could make today to bring yourself closer to that alignment?",
                        "What simple, intentional act could you introduce into your day to call you back to presence, purpose, and prayer?"
                    ]
                ];
                this.animatedItems = [];
                this.optionRects = [];

                this.registerActions();
                this.updateTexts();
            }

            registerActions() {
                this.registerAction('MouseClick', 'MOUSE_CLICK');
            }

            updateTexts() {
                this.optionRects = [];
                const options = this.pillarOptions[this.currentPillar];
                const isMobile = window.innerWidth <= 768;
                const canvas = this.game.canvas;

                const startY = isMobile ? 380 : 500;
                const spacing = isMobile ? 80 : 90;
                const rectHeight = isMobile ? 60 : 60;
                const rectWidth = isMobile ? 350 : 400;

                for (let i = 0; i < options.length; i++) {
                    const y = startY + i * spacing;
                    this.optionRects.push({
                        x: (canvas.width / 2) - rectWidth/2,
                        y: y - rectHeight/2,
                        width: rectWidth,
                        height: rectHeight,
                        text: options[i],
                        index: i
                    });
                }

                this.state = 'ShowOptions';
            }

            loadItemTexture() {
                if (this.currentPillar <= 7) {
                    const anim = {
                        currentScale: 0.0,
                        targetScale: 0.6,
                        speed: 2.5,
                        x: 100 + (this.animatedItems.length * 120),
                        y: 1000,
                        pillar: this.currentPillar - 1,
                        imageType: this.getPillarImageType(this.currentPillar - 1)
                    };
                    this.animatedItems.push(anim);
                }
            }

            getPillarImageType(pillarIndex) {
                const imageTypes = [
                    'heart',    // Emotional
                    'trophy',   // Purpose
                    'money',    // Financial
                    'ring',     // Physical
                    'brain',    // Mental
                    'plant',    // Environmental
                    'flame'     // Spiritual
                ];
                return imageTypes[pillarIndex] || 'heart';
            }

            handleClick(x, y) {
                if (this.state !== 'ShowOptions') return;

                for (let i = 0; i < this.optionRects.length; i++) {
                    const rect = this.optionRects[i];
                    if (x >= rect.x && x <= rect.x + rect.width &&
                        y >= rect.y && y <= rect.y + rect.height) {

                        console.log('Selected option:', rect.text);

                        // Get the reflection message for this option
                        const reflectionMessage = this.pillarReflections[this.currentPillar][rect.index];

                        // Update pillar and load texture
                        this.currentPillar++;
                        this.loadItemTexture();

                        // Show reflection scene
                        this.game.lastImageType = this.getPillarImageType(this.currentPillar - 1);
                        let nextScene;
                        if (this.currentPillar >= this.TOTAL_PILLARS) {
                            nextScene = new Scene_End(this.game);
                            this.journeyFinished = true;
                        } else {
                            nextScene = new Scene_Game(this.game);
                        }

                        this.game.changeScene('REFLECTION', new Scene_Reflection(this.game, reflectionMessage, nextScene));
                        break;
                    }
                }
            }
        // End Scene
        class Scene_End extends Scene {
            constructor(gameEngine) {
                super(gameEngine);
                this.registerActions();
            }

            registerActions() {
                this.registerAction('Escape', 'QUIT');
            }

            update(dt) {
                // No updates needed
            }

            render(ctx) {
                const canvas = ctx.canvas;
                const isMobile = window.innerWidth <= 768;

                ctx.fillStyle = '#549aa3';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const titleSize = isMobile ? 80 : 100;
                const subtitleSize = isMobile ? 45 : 60;
                const footerSize = isMobile ? 40 : 50;
                const linkSize = isMobile ? 32 : 45;
                const instructionSize = isMobile ? 28: 30;

                ctx.fillStyle = 'black';
                ctx.font = `bold ${titleSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('Congratulations!', canvas.width / 2, isMobile ? 150 : 250);

                ctx.font = `${subtitleSize}px Arial`;
                const subtitleY = isMobile ? 220 : 400;
                if (isMobile) {
                    ctx.fillText('You have discovered', canvas.width / 2, subtitleY);
                    ctx.fillText('all 7 Pillars of Self!', canvas.width / 2, subtitleY + 50);
                } else {
                    ctx.fillText('You have discovered all 7 Pillars of Self!', canvas.width / 2, subtitleY);
                }

                ctx.font = `${footerSize}px Arial`;
                const footerY = isMobile ? 350 : 600;
                if (isMobile) {
                    ctx.fillText('Keep growing with', canvas.width / 2, footerY);
                    ctx.fillText('Emotional Fitness Academy', canvas.width / 2, footerY + 50);
                } else {
                    ctx.fillText('Keep growing with Emotional Fitness Academy', canvas.width / 2, footerY);
                }

                ctx.font = `${linkSize}px Arial`;
                const linkY = isMobile ? 480 : 750;
                ctx.fillStyle = '#0000EE';
                ctx.fillText('https://efitacademy.ca/booking/', canvas.width / 2, linkY);
                this.linkRect = {
                    x: canvas.width / 2 - 400,
                    y: linkY - 40,
                    width: 800,
                    height: 60
                };

                ctx.font = `${instructionSize}px Arial`;
                const instructionY = isMobile ? 550 : 900;
                if (isMobile) {
                    ctx.fillText('Tap anywhere to return to menu', canvas.width / 2, instructionY);
                } else {
                    ctx.fillText('Click anywhere to return to menu', canvas.width / 2, instructionY);
                }
            }

            handleClick(x, y) {
                if (this.linkRect) {
                    if (x >= this.linkRect.x && x <= this.linkRect.x + this.linkRect.width &&
                        y >= this.linkRect.y && y <= this.linkRect.y + this.linkRect.height) {
                        window.open('https://efitacademy.ca/booking/', '_blank');
                        return;
                    }
                }
                this.game.changeScene('MENU', new Scene_Menu(this.game));
            }

            handleAction(command) {
                if (command.getType() === 'START' && command.getName() === 'QUIT') {
                    this.onEnd();
                }
            }

            onEnd() {
                console.log('Exiting game');
            }
        }
        // Main Game Engine
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.running = true;
                this.currentScene = '';
                this.sceneMap = new Map();
                this.simulationSpeed = 1;
                this.imageManager = new ImageManager();

                this.initializeGame();
            }

            async initializeGame() {
                // Load all images first
                await this.imageManager.loadAllImages();

                // Set up canvas
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('orientationchange', () => this.resizeCanvas());

                // Event listeners
                this.setupEventListeners();

                // Start with menu scene
                this.changeScene('MENU', new Scene_Menu(this));

                // Hide loading
                document.getElementById('loading').style.display = 'none';

                // Start game loop
                this.lastTime = 0;
                this.gameLoop();
            }

            resizeCanvas() {
                const aspectRatio = 1920 / 1080; // 16:9 aspect ratio
                const isMobile = window.innerWidth <= 768;

                if (window.innerWidth / window.innerHeight > aspectRatio) {
                    this.canvas.style.height = Math.min(window.innerHeight * 0.95, 1080) + 'px';
                    this.canvas.style.width = (parseFloat(this.canvas.style.height) * aspectRatio) + 'px';
                } else {
                    this.canvas.style.width = Math.min(window.innerWidth * 0.95, 1920) + 'px';
                    this.canvas.style.height = (parseFloat(this.canvas.style.width) / aspectRatio) + 'px';
                }

                const rect = this.canvas.getBoundingClientRect();
                this.scaleX = this.canvas.width / rect.width;
                this.scaleY = this.canvas.height / rect.height;
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });

                this.canvas.addEventListener('click', (e) => {
                    this.handleMouseClick(e);
                });

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleTouch(e);
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            handleKeyDown(e) {
                const scene = this.getCurrentScene();
                if (scene) {
                    const actionMap = scene.getActionMap();
                    if (actionMap.has(e.key)) {
                        const command = new Command(actionMap.get(e.key), 'START');
                        scene.handleAction(command);
                    }
                }
            }

            handleMouseClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * this.scaleX;
                const y = (e.clientY - rect.top) * this.scaleY;

                const scene = this.getCurrentScene();
                if (scene && scene.handleClick) {
                    scene.handleClick(x, y);
                }
            }

            handleTouch(e) {
                if (e.touches.length > 0) {
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = (touch.clientX - rect.left) * this.scaleX;
                    const y = (touch.clientY - rect.top) * this.scaleY;

                    const scene = this.getCurrentScene();
                    if (scene && scene.handleClick) {
                        scene.handleClick(x, y);
                    }
                }
            }

            getCurrentScene() {
                return this.sceneMap.get(this.currentScene);
            }

            changeScene(sceneName, scene, endCurrentScene = false) {
                if (endCurrentScene) {
                    this.sceneMap.delete(this.currentScene);
                }

                if (sceneName === 'PLAY' || sceneName === 'END') {
                    this.sceneMap.set(sceneName, scene);
                } else if (!this.sceneMap.has(sceneName)) {
                    this.sceneMap.set(sceneName, scene);
                }

                this.currentScene = sceneName;
            }

            gameLoop(currentTime = 0) {
                if (!this.running) return;

                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                const scene = this.getCurrentScene();
                if (scene) {
                    scene.update(deltaTime);
                    scene.render(this.ctx);
                }

                requestAnimationFrame((time) => this.gameLoop(time));
            }

            isRunning() {
                return this.running;
            }

            quit() {
                this.running = false;
                console.log('Game quit');
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new GameEngine();
        });
    </script>
</body>
</html>
